# 문자열 계산기
문자열 계산기 구현을 통한 테스트와 리팩토링을 목표로 한다.

## main() 메소드를 활용한 테스트
### 문제점
일반적으로 main() 메소드를 활용해 소스코드가 정상적으로 동작하는지 확인하고, 콘솔을 통해 의도한 결과 값이 정상적으로 출력되는지 확인한다.
이러한 방식에서는 실제로 서비스를 담당하는 코드와 테스트하는 코드로 구분이 되게 된다. 한 클래스 내에서 목적이 다른 코드가 함께하게 되는 문제점이 있다.
테스트 코드의 경우 테스트 단계에서만 필요하기 때문에 굳이 서비스 시점에 같이 배포할 필요가 없다.

### 해결 1 - 테스트 담당 클래스로 코드 분리
이 문제를 해결하기 위해 프로덕션 코드와 테스트 코드를 분리한다.
### 단점
main() 메소드의 테스트 코드를 테스트 클래스로 분리를 했지만, 이 역시 메소드 하나에서 프로덕션 코드의 여러 메소드를 동시에 테스트하고 있어 유지보수에 단점이 있다.
프로덕션 코드가 복잡해지면 main()의 테스트 또한 복잡해진다.

### 해결 2 - 테스트 코드를 각 메소드별로 분리
테스트 코드를 각 메소드 별로 분리하는 방법을 사용할 수 있다.
### 단점
하지만, 이 방법은 여전히 여러 메소드를 동시에 테스트 하게 된다. 
현재 내가 구현하고 있는 메소드에만 집중해서 테스트하기가 어렵다. 
주석처리하는 것 방식이 있지만 불합리적이다.
또한, 위의 방식은 모두 수동으로 로직의 동작과 콘솔의 결과를 확인해주어야 하는 불편함이 있다. 
예제 처럼 간단한 경우는 수동으로 해도 문제가 없지만, 복잡도가 올라간다면 구현 이후 테스트를 하기가 어렵다. 

### 최종 해결 - JUnit 라이브러리 사용
앞서 접한 내가 관심있는 메소드가 아니라 전체를 테스트해야하는 것, 수동으로 코드를 확인해야하는 것, 유지보수를 하며 복잡한 코드의 로직을 계산하고 확인해야 하는 불편함을 해결하기 위해서 JUnit 라이브러리를 사용한다.
### 장점
JUnit을 통해 관심있는 메소드만 테스트하고, 테스트 자동화가 가능하다. 


## JUnit을 사용한 테스트
### 개념
JUnit은 단위 테스트 프레임워크 중 하나이다.
### 장점
사용하기 쉽고 학습 비용이 낮다.
### JUnit 사용
- @test 애노테이션으로 메소드별 테스트 가능
- Assert로 결과 값 확인 자동화
- @BeforeEach 애노테이션으로 초기화 중복 코드 제거
### AssertJ 사용
- JUnit의 Assert의 코드는 직관성에서 한계가 있어 AssertJ로 명시적인 코드 작성

## 문자열 계산기 
### 요구사항
- 전달하는 문자를 구분자로 분리한 후 각 숫자의 합을 구해 반환
- 쉼표(,) 또는 콜론(:)을 구분자로 가지는 문자열을 전달하는 경우 구분자를 기준으로 분리한 각 숫자의 합을 반환
- 앞의 기본 구분자(쉼표, 콜론) 외에 커스텀 구분자를 지정할 수 있음
  - 커스텀 구분자는 문자열 앞부분의 "//"와 "\n" 사이에 위치한 문자를 커스텀 구분자로 사용
- 문자열 계산기에 음수를 전달하는 경우 RuntimeException으로 예외 처리
### JUnit5를 사용해 테스트 코드 작성
1. 빈 문자열 또는 null 값 입력시 0 반환
2. 숫자 하나를 문자열로 입력할 경우 해당 숫자를 반환
3. 쉼표 구분자를 사용해 숫자 두개 이상 입력할 경우 숫자의 합을 반환
4. 쉼표 이외에 콜론 구분자를 사용해 숫자 두개 이상 입력할 경우 숫자의 합을 반환
5. 커스텀 구분자를 사용해 숫자 두개 이상 입력할 경우 숫자의 합을 반환
6. 음수를 전달하는 경우 RuntimeException 예외 처리
### 로직 구현
1. 빈 문자열 또는 null 값 입력시 return 0
2. 커스텀 구분자 있는 경우와 일반 구분자 사용 경우 구분
3. 구분자로 분리한 각 숫자의 합 연산
4. 숫자에 음수가 있을 시 RuntimeException 반환
5. 테스트 코드 성공 확인
### 리팩토링
다음 세 가지 요구사항에 맞춰 리팩토링 진행
- 메소드가 한 가지 책임만 가지도록 구현
- 인덴트(indent, 들여쓰기) 깊이를 1단계로 유지
- else를 사용하지 않기

1. 구현한 코트는 add() 메소드에 모든 역할이 수행되고 있음으로 작은 단위의 메소드로 분리하는 작업을 수행
2. 인덴트 깊이 1단계는 유지 되었으나 else를 사용하지 않도록 코드를 수정

